.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "sense 3"
.TH sense 3 "2009-08-02" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
common::sense \- save a tree AND a kitten, use common::sense!
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use common::sense;
\&
\& # roughly the same as, with much lower memory usage:
\& #
\& # use strict qw(vars subs);
\& # use feature qw(say state switch);
\& # no warnings;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements some sane defaults for Perl programs, as defined by
two typical (or not so typical \- use your common sense) specimens of
Perl coders.
.IP "no warnings" 4
.IX Item "no warnings"
The dreaded warnings. Even worse, the horribly dreaded \f(CW\*(C`\-w\*(C'\fR switch. Even
though we don't care if other people use warnings (and certainly there are
useful ones), a lot of warnings simply go against the spirit of Perl, most
prominently, the warnings related to \f(CW\*(C`undef\*(C'\fR. There is nothing wrong with
\&\f(CW\*(C`undef\*(C'\fR: it has well-defined semantics, it is useful, and spitting out
warnings you never asked for is just evil.
.Sp
So every module needs \f(CW\*(C`no warnings\*(C'\fR to avoid somebody accidentally using
\&\f(CW\*(C`\-w\*(C'\fR and forcing his bad standards on our code. No will do.
.Sp
Funnily enough, perllexwarn explicitly mentions \f(CW\*(C`\-w\*(C'\fR (and not in a
favourable way), but standard utilities, such as prove, or MakeMaker
when running \f(CW\*(C`make test\*(C'\fR enable them blindly.
.IP "use strict qw(subs vars)" 4
.IX Item "use strict qw(subs vars)"
Using \f(CW\*(C`use strict\*(C'\fR is definitely common sense, but \f(CW\*(C`use strict
\&\*(Aqrefs\*(Aq\*(C'\fR definitely overshoots it's usefulness. After almost two
decades of Perl hacking, we decided that it does more harm than being
useful. Specifically, constructs like these:
.Sp
.Vb 1
\&   @{ $var\->[0] }
.Ve
.Sp
Must be written like this (or similarly), when \f(CW\*(C`use strict \*(Aqrefs\*(Aq\*(C'\fR is in
scope, and \f(CW$var\fR can legally be \f(CW\*(C`undef\*(C'\fR:
.Sp
.Vb 1
\&   @{ $var\->[0] || [] }
.Ve
.Sp
This is annoying, and doesn't shield against obvious mistakes such as
using \f(CW""\fR, so one would even have to write:
.Sp
.Vb 1
\&   @{ defined $var\->[0] ? $var\->[0] :  [] }
.Ve
.Sp
\&... which nobody with a bit of common sense would consider
writing. Curiously enough, sometimes, perl is not so strict, as this works
even with \f(CW\*(C`use strict\*(C'\fR in scope:
.Sp
.Vb 1
\&   for (@{ $var\->[0] }) { ...
.Ve
.Sp
If that isnt hipocrasy! And all that from a mere program!
.IP "use feature qw(say state given)" 4
.IX Item "use feature qw(say state given)"
We found it annoying that we always have to enable extra features. If
something breaks because it didn't anticipate future changes, so be
it. 5.10 broke almost all our \s-1XS\s0 modules and nobody cared either \- and few
modules that are no longer maintained work with newer versions of Perl,
regardless of use feature.
.Sp
If your code isn't alive, it's dead, jim.
.IP "much less memory" 4
.IX Item "much less memory"
Just using all those pragmas together waste <blink>\fI\f(BI776\fI kilobytes\fR</blink> of precious memory in my perl, for \fIevery single perl process
using our code\fR, which on our machines, is a lot. In comparison, this
module only uses \fI\f(BIfour\fI\fR kilobytes (I even had to write it out so
it looks like more) of memory on the same platform.
.Sp
The money/time/effort/electricity invested in these gigabytes (probably
petabytes globally!) of wasted memory could easily save 42 trees, and a
kitten!
.SH "THERE IS NO 'no common::sense'!!!! !!!! !!"
.IX Header "THERE IS NO 'no common::sense'!!!! !!!! !!"
This module doesn't offer an unimport. First of all, it wastes even more
memory, second, and more importantly, who with even a bit of common sense
would want no common sense?
.SH "STABILITY AND FUTURE VERSIONS"
.IX Header "STABILITY AND FUTURE VERSIONS"
Future versions might change just about everything in this module. We
might test our modules and upload new ones working with newer versions of
this module, and leave you standing in the rain because we didn't tell
you.
.PP
Most likely, we will pick a few useful warnings, instead of just disabling
all of them. And maybe we will load some nifty modules that try to emulate
\&\f(CW\*(C`say\*(C'\fR or so with perls older than 5.10 (this module, of course, should
work with older perl versions \- supporting 5.8 for example is just common
sense at this time. Maybe not in the future, but of course you can trust
our common sense).
.SH "WHAT OTHER PEOPLE HAVE TO SAY ABOUT THIS MODULE"
.IX Header "WHAT OTHER PEOPLE HAVE TO SAY ABOUT THIS MODULE"
Pista Palo
.PP
.Vb 1
\&   "Something in short supply these days..."
.Ve
.PP
Steffen Schwigon
.PP
.Vb 4
\&   "This module is quite for sure *not* just a repetition of all the other
\&   \*(Aquse strict, use warnings\*(Aq\-approaches, and it\*(Aqs also not the opposite.
\&   [...] And for its chosen middle\-way it\*(Aqs also not the worst name ever.
\&   And everything is documented."
.Ve
.PP
\&\s-1BKB\s0
.PP
.Vb 2
\&   "[Deleted \- thanks to Steffen Schwigon for pointing out this review was
\&   in error.]"
.Ve
.PP
Somni
.PP
.Vb 3
\&   "the arrogance of the guy"
\&   "I swear he tacked somenoe else\*(Aqs name onto the module
\&   just so he could use the royal \*(Aqwe\*(Aq in the documentation"
.Ve
.PP
dngor
.PP
.Vb 2
\&   "Heh.  \*(Aq"<elmex at ta\-sa.org>"\*(Aq  The quotes are semantic
\&   distancing from that e\-mail address."
.Ve
.PP
Jerad Pierce
.PP
.Vb 3
\&   "Awful name (not a proper pragma), and the SYNOPSIS doesn\*(Aqt tell you
\&   anything either. Nor is it clear what features have to do with "common
\&   sense" or discipline."
.Ve
.PP
acme
.PP
.Vb 1
\&   "THERE IS NO \*(Aqno common::sense\*(Aq!!!! !!!! !!"
.Ve
.PP
crab
.PP
.Vb 1
\&   "i wonder how it would be if joerg schilling wrote perl modules."
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://home.schmorp.de/
\&
\& Robin Redeker, "<elmex at ta\-sa.org>".
.Ve
